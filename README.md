A. Целая куча задач
Ограничение времени	1 секунда
Ограничение памяти	64.0 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Молодая команда разработчиков была нанята, чтобы разработать админку для b2b-компании, занимающейся обработкой текстовых данных. Вашей задачей является создание алгоритма, который бы позволял обработать наибольшее количество заказов.

Заказы представляет собой массив объектов со следующими полями: interface Order { id: string; executionTime: number; expiredAt: number; }

Где поле id представляет собой уникальный идентификатор заказа, поле executionTime содержит количество минут, необходимых для выполнения заказа, а поле expiredAt крайний срок (в минутах), к которому заказ должен быть выполнен.

Работа алгоритма начинается в нулевой момент времени.

Пример 1
Ввод	Вывод
[{"index":"0000","executionTime":100,"expiredAt":200},{"index":"0001","executionTime":1000,"expiredAt":1250},{"index":"0002","executionTime":200,"expiredAt":1300},{"index":"0003","executionTime":2000,"expiredAt":3200}]
3
Пример 2
Ввод	Вывод
[{"index":"0000","executionTime":1,"expiredAt":2}]
1
Пример 3
Ввод	Вывод
[{"index":"0000","executionTime":3,"expiredAt":2},{"index":"0001","executionTime":4,"expiredAt":3}]
0
Примечания
Решение требуется оформить по шаблону: ``` module.exports = function(orders) {
// основная функция
// ...
}

// вспомогательные функции
// ... ```


B. Луковый коммивояжёр
Ограничение времени	1 секунда
Ограничение памяти	64.0 Мб
Ввод	input.js
Вывод	output.txt
Цифровизация добралась и до известного коммивояжёра по прозвищу "Луковый Странник", теперь он обязан постоянно отчитываться перед налоговой страны N о том, какие города собирается посетить.

Чтобы упростить данный процесс, коммивояжёр обратился к вам за помощью с разработкой специальной функции-обёртки onionWrapper.

Функция должна делать следующее:

Сперва onionWrapper принимает произвольное количество городов (строк), но всегда не меньше одного.
// Пример
onionWrapper('city1')('city2')...('cityN')
Затем ровно один раз onionWrapper принимает произвольную функцию налоговой и возвращает другую функцию, которая "помнит" переданные ранее значения (все города и функцию налоговой). Назовём такую функцию superOnion.
// Пример
const superOnion = onionWrapper('city1')('city2')('city3')(taxFunc)
При этом функция superOnion может вести себя следующим образом:
// Вычёркивает город city1 из своего внутреннего списка городов и вызывает функцию налоговой
// taxFunc с массивом оставшихся городов ["city2","city3"] в качестве входного параметра
superOnion('city1')();

// Вычёркивает города city2 и city3 из своего внутреннего списка городов и вызывает
// функцию налоговой taxFunc с пустым массивом [] в качестве входного параметра
superOnion('city2')('city3')();
Также важно учесть, что при первоначальном составлении списка городов (то есть при передаче строк в onionWrapper) Луковый Странник часто рассеян и может записывать один и тот же город несколько раз, однако superOnion знает об этом и будет вычёркивать все повторы такого города после его посещения (то есть при передаче строки такого города в superOnion).

Примечания
Задачу требуется решить на JavaScript и оформить решение по шаблону:

function onionWrapper(stringOrFunction) {
  // Ваш код
}

module.exports = onionWrapper;


C. Парсер
Ограничение времени	5 секунд
Ограничение памяти	64.0 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Задача
Напишите функцию parse, которая на вход принимает 3 аргумента:

Функцию для похода за данными
Урл по которому лежат данные
Целое число - размер чанка
Функция должная ходить за разметкой по указаному урлу с помощью переданного фетчера, возвращать асинхронно итерируемый объект, который перебирает элементы полученной разметки и возвращает чанками размера chunkSize значения полей value элементов типа 'data'. Если встречается в разметке элемент типа provider, то этот элемент заменятся на результат работы функции fetcher(src), где src значение одноименного поля элемента

interface ItemProvider {
  type: 'provider';
  src: string;
}

interface ItemData {
  type: 'data';
  value: any;
  children: Array<ItemData | ItemProvider>;
}

type Fetcher = (src: string) => Promise<Array<ItemData | ItemProvider>>;
Шаблон решения

modules.exports.parse = function(fetcher: Fetcher, src: string, chunkSize: number): AsyncIterable<any[]> {
  // код
};
Пример

Пусть есть ручка src1. Ее ответ:

 [
    {
      type: 'data',
      value: 1
    },
    {
      type: 'data',
      value: 2,
      children: [
        {
          type: 'data',
          value: 1
        },
        {
          type: 'provider',
          src: 'src2'
        },
      ]
    },
    {
      type: 'data',
      value: 3
    }
  ]
и ручка src2, ее ответ:

  [
    {
      type: 'data',
      value: 1
    },
    {
      type: 'data',
      value: 2
    },
    {
      type: 'data',
      value: 3
    },
    {
      type: 'data',
      value: 4
    }
     ]
тогда при вызове вашей функции со вторым аргументом src1 и третим аргументов 3, чанки будут следующими:

[1, 2, 1]
[1, 2, 3]
[4, 3]

D. Ремонт клавиатуры
Ограничение времени	1 секунда
Ограничение памяти	64.0 Мб
Ввод	input.txt
Вывод	output.txt
Алексей работает в техподдержке одного малоизвестного сервиса и ежедневно заполняет множество форм, а так же общается в чате с клиентами. У Алексея старая клавиатура, где любое нажатие клавиши может вызывать ложные срабатывания, а иногда и вовсе залипать. К тому же, когда он вставляет какой-то большой текст из буфера обмена, то часто не замечает что тест дублируется. Компания не может позволить выделить средства на новую клавиатуру для Алексея и чтобы не лишиться премии он решил прогонять напечатанное через программу, которая бы исправляла введенный с клавиатуры текст. Помогите Алексею в этом.

Вам нужно написать функцию, которая на вход принимает текст, набранный при помощи сломанной клавиатуры, а так же функцию изменения раскладки для одного символа и возвращает исправленный текст.

Шаблон решения:
module.exports = function (text, changeLang) {
 //Ваш код...
}
Алексею важно чтобы правильно работали все символьные клавиши, а так же комбинации:
- вставка текста из буфера обмена
- смена раскладки клавиатуры
- backspace

Пояснение к примерам:
- Во входных данных символ [_] обозначает время между нажатиями на клавиши, а его отсутствие - сбой клавиатуры (если только текст не был добавлен из буфера обмена),
- Смена раскладки обозначается [l] (раскладки две) для смены раскладки используйте функцию changeLang(char: string): string,
- Команда вставки текста из буфера обмена обозначается [v]
- Клавиша backspace обозначается [b]

Пример 1
Ввод	Вывод
Y[_]aa[_]nnnn[_]d[_]e[_]xxx[_]![_][b][b][b]
Yandex
Пример 2
Ввод	Вывод
H[_]e[_]l[_]ll[_]o[_]
[_][l][l][_]v[_]bb[_]h
Hello
мир
Пример 3
Ввод	Вывод
T[_]o[_]d[_]o[_]:[_]
[_][v][v]погладь котапогладь кота
Todo:
погладь кота


E. Душа компании
Ограничение времени	1 секунда
Ограничение памяти	64.0 Мб
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Администратор Василий работает в игровом антикафе. В этом антикафе есть несколько комнат, рассчитанных на разное количество людей. Комнаты расположены вдоль длинного коридора и каждого нового гостя Василий отправляет в первую попавшуюся пустую комнату, либо комнату где уже есть гости, но осталось свободное место. Если в антикафе больше некуда посадить нового гостя - гость уходит.

Если какая-то комната рассчитана на 2 или более людей - в этой комнате находится игра на компанию и Василий, как душа компании не может оставить человека одного в такой комнате. Он идет играть вместе с ним, до тех пор как в эту комнату не придет хотя бы еще один гость. При этом если в какой-то момент окажется так, что в нескольких комнатах с игрой на компанию сидит по одному посетителю - Василий идет играть в первую по коридору комнату, на все комнаты его все же не хватит :(

Вам дана выжимка всех посетителей за один день (время с 0 до 23 часов включительно, а интервал с 23 до 0 - технические работы). Найдите промежутки времени когда Василий играл вместе с гостем

Формат ввода
Ваша функция получает объект с полями users и rooms

users - это массив пользователей в формате [время_начала, время_окончания]

Время начала и окончания являются целыми числом от 0 до 23 включительно
Все пользователи передаются в порядке как они приходили в антикафе
Не может быть пользователя, который пришел в 10 вечера и ушел в 1 ночи, так как антикафе закрыто с 23 до 0
rooms: размеры комнат в антикафе по порядку в коридоре

Формат вывода
Функция должна вернуть массив промежутков времени, в которые Василий играет с кем-то в формате [время_начала, время_окончания]